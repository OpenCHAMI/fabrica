// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT

package handlers

import (
	"encoding/json"
	"net/http"

	"{{.ModulePath}}/pkg/policy"
)

// PolicyHandlers provides HTTP endpoints for managing Casbin policies
type PolicyHandlers struct {
	casbinPolicy *policy.CasbinPolicy
}

// NewPolicyHandlers creates policy management handlers
func NewPolicyHandlers(casbinPolicy *policy.CasbinPolicy) *PolicyHandlers {
	return &PolicyHandlers{
		casbinPolicy: casbinPolicy,
	}
}

// GetPolicies returns all policy rules
// GET /api/v1/policies
func (h *PolicyHandlers) GetPolicies(w http.ResponseWriter, r *http.Request) {
	policies, err := h.casbinPolicy.GetPolicy()
	if err != nil {
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	response := map[string]interface{}{
		"policies": policies,
		"count":    len(policies),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// AddPolicyRequest represents a request to add a policy
type AddPolicyRequest struct {
	Subject string `json:"subject"` // User ID or role name
	Object  string `json:"object"`  // Resource type (e.g., "Device")
	Action  string `json:"action"`  // Operation (list, get, create, update, delete, *)
}

// AddPolicy adds a new policy rule
// POST /api/v1/policies
func (h *PolicyHandlers) AddPolicy(w http.ResponseWriter, r *http.Request) {
	var req AddPolicyRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, err)
		return
	}

	// Validate request
	if req.Subject == "" || req.Object == "" || req.Action == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("subject, object, and action are required"))
		return
	}

	ok, err := h.casbinPolicy.AddPolicy(req.Subject, req.Object, req.Action)
	if err != nil {
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if !ok {
		respondError(w, http.StatusConflict, fmt.Errorf("policy already exists"))
		return
	}

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message": "Policy added successfully",
		"policy": map[string]string{
			"subject": req.Subject,
			"object":  req.Object,
			"action":  req.Action,
		},
	})
}

// RemovePolicy removes a policy rule
// DELETE /api/v1/policies
func (h *PolicyHandlers) RemovePolicy(w http.ResponseWriter, r *http.Request) {
	var req AddPolicyRequest // Reuse same structure
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, err)
		return
	}

	ok, err := h.casbinPolicy.RemovePolicy(req.Subject, req.Object, req.Action)
	if err != nil {
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if !ok {
		respondError(w, http.StatusNotFound, fmt.Errorf("policy not found"))
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{
		"message": "Policy removed successfully",
	})
}

// RoleAssignmentRequest represents a role assignment request
type RoleAssignmentRequest struct {
	User string `json:"user"` // User ID
	Role string `json:"role"` // Role name
}

// AddRoleForUser assigns a role to a user
// POST /api/v1/roles
func (h *PolicyHandlers) AddRoleForUser(w http.ResponseWriter, r *http.Request) {
	var req RoleAssignmentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, err)
		return
	}

	if req.User == "" || req.Role == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("user and role are required"))
		return
	}

	ok, err := h.casbinPolicy.AddRoleForUser(req.User, req.Role)
	if err != nil {
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if !ok {
		respondError(w, http.StatusConflict, fmt.Errorf("role assignment already exists"))
		return
	}

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"message": "Role assigned successfully",
		"assignment": map[string]string{
			"user": req.User,
			"role": req.Role,
		},
	})
}

// RemoveRoleFromUser removes a role from a user
// DELETE /api/v1/roles
func (h *PolicyHandlers) RemoveRoleFromUser(w http.ResponseWriter, r *http.Request) {
	var req RoleAssignmentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, err)
		return
	}

	ok, err := h.casbinPolicy.DeleteRoleForUser(req.User, req.Role)
	if err != nil {
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	if !ok {
		respondError(w, http.StatusNotFound, fmt.Errorf("role assignment not found"))
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{
		"message": "Role removed successfully",
	})
}

// GetRolesForUser returns all roles for a user
// GET /api/v1/roles?user=<user_id>
func (h *PolicyHandlers) GetRolesForUser(w http.ResponseWriter, r *http.Request) {
	userID := r.URL.Query().Get("user")
	if userID == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("user parameter is required"))
		return
	}

	roles, err := h.casbinPolicy.GetRolesForUser(userID)
	if err != nil {
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"user":  userID,
		"roles": roles,
		"count": len(roles),
	})
}

// GetUsersForRole returns all users that have a role
// GET /api/v1/users-with-role?role=<role_name>
func (h *PolicyHandlers) GetUsersForRole(w http.ResponseWriter, r *http.Request) {
	roleName := r.URL.Query().Get("role")
	if roleName == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("role parameter is required"))
		return
	}

	users, err := h.casbinPolicy.GetUsersForRole(roleName)
	if err != nil {
		respondError(w, http.StatusInternalServerError, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"role":  roleName,
		"users": users,
		"count": len(users),
	})
}
