// Code generated by inventory-codegen. DO NOT EDIT.
// This file provides a reconciler for {{ .Name }} resources.
// 
// The reconciler pattern enables declarative infrastructure management by:
//   - Automatically reconciling Spec (desired state) with Status (observed state)
//   - Reacting to resource changes via events
//   - Integrating with the workflow engine for complex operations
//
// To customize reconciliation logic, edit the reconcile{{ .Name }} method below.
package reconcilers

import (
	"context"
	"time"

	"github.com/openchami/inventory/pkg/reconcile"
	"github.com/openchami/inventory/pkg/events"
	"{{ .Package }}"
)

// {{ .Name }}Reconciler reconciles {{ .Name }} resources.
//
// This reconciler:
//   - Observes {{ .Name }} resources and updates their Status
//   - Emits events when significant state changes occur
//   - Can trigger workflows for complex operations
//   - Runs periodically and on resource changes
type {{ .Name }}Reconciler struct {
	reconcile.BaseReconciler
	
	// Add custom fields here if needed
	// Example:
	// httpClient *http.Client
	// config     Config
}

// NewDefault{{ .Name }}Reconciler creates a default {{ .Name }} reconciler.
//
// This is called during server startup to register the reconciler.
//
// Parameters:
//   - client: Client for accessing resource storage
//   - eventBus: Event bus for publishing events
//
// Returns:
//   - *{{ .Name }}Reconciler: Initialized reconciler
func NewDefault{{ .Name }}Reconciler(client reconcile.ClientInterface, eventBus events.EventBus) *{{ .Name }}Reconciler {
	return &{{ .Name }}Reconciler{
		BaseReconciler: reconcile.BaseReconciler{
			Client:   client,
			EventBus: eventBus,
			Logger:   reconcile.NewDefaultLogger(),
		},
	}
}

// GetResourceKind returns the resource kind this reconciler handles.
func (r *{{ .Name }}Reconciler) GetResourceKind() string {
	return "{{ .Name }}"
}

// Reconcile brings {{ .Name }} to desired state.
//
// This method is called:
//   - When a {{ .Name }} resource is created/updated/deleted
//   - Periodically (every 5 minutes by default)
//   - When manually triggered via API
//
// The reconciler should:
//   1. Read the Spec (desired state)
//   2. Observe the actual state
//   3. Update Status to reflect observed state
//   4. Take actions to align actual with desired
//   5. Emit events for significant changes
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The {{ .Name }} resource to reconcile
//
// Returns:
//   - Result: Indicates if/when to requeue
//   - error: If reconciliation failed
func (r *{{ .Name }}Reconciler) Reconcile(ctx context.Context, resource interface{}) (reconcile.Result, error) {
	res := resource.(*{{ .PackageAlias }}.{{ .Name }})

	r.Logger.Debugf("Reconciling {{ .Name }} %s/%s", res.Kind, res.GetUID())

	// Call custom reconciliation logic
	if err := r.reconcile{{ .Name }}(ctx, res); err != nil {
		r.Logger.Errorf("Reconciliation failed for {{ .Name }} %s: %v", res.GetUID(), err)
		
		// Set error condition
		r.SetCondition(res, "Ready", "False", "ReconcileError", err.Error())
		
		// Requeue with backoff (30 seconds)
		return reconcile.Result{Requeue: true, RequeueAfter: 30 * time.Second}, err
	}

	// Set success condition
	r.SetCondition(res, "Ready", "True", "ReconcileSuccess", "Reconciliation successful")

	// Update status in storage
	if err := r.UpdateStatus(ctx, res); err != nil {
		r.Logger.Errorf("Failed to update status for {{ .Name }} %s: %v", res.GetUID(), err)
		return reconcile.Result{Requeue: true, RequeueAfter: 10 * time.Second}, err
	}

	// Emit reconciliation event
	eventType := "io.openchami.inventory.{{ .PluralName }}.reconciled"
	if err := r.EmitEvent(ctx, eventType, res); err != nil {
		r.Logger.Warnf("Failed to emit event for {{ .Name }} %s: %v", res.GetUID(), err)
		// Don't fail reconciliation if event emission fails
	}

	// Requeue after 5 minutes for periodic reconciliation
	return reconcile.Result{RequeueAfter: 5 * time.Minute}, nil
}

// reconcile{{ .Name }} contains custom reconciliation logic.
//
// ⚠️ IMPORTANT: This function is generated ONCE and will NOT be overwritten.
// Edit this method to implement {{ .Name }}-specific reconciliation logic.
//
// Example implementation:
//
//	func (r *{{ .Name }}Reconciler) reconcile{{ .Name }}(ctx context.Context, res *{{ .PackageAlias }}.{{ .Name }}) error {
//	    // 1. Read desired state from Spec
//	    desiredAddress := res.Spec.Address
//	    
//	    // 2. Observe actual state (e.g., connect to hardware)
//	    // actualState, err := r.observeActualState(ctx, res)
//	    // if err != nil {
//	    //     return fmt.Errorf("failed to observe state: %w", err)
//	    // }
//	    
//	    // 3. Update Status with observed state
//	    // res.Status.Connected = actualState.Connected
//	    // res.Status.Version = actualState.Version
//	    // res.Status.LastSeen = time.Now().Format(time.RFC3339)
//	    
//	    // 4. Emit events for significant changes
//	    // if !wasConnected && res.Status.Connected {
//	    //     r.EmitEvent(ctx, "io.openchami.inventory.{{ .PluralName }}.connected", res)
//	    // }
//	    
//	    return nil
//	}
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - res: The {{ .Name }} resource to reconcile
//
// Returns:
//   - error: If reconciliation failed
func (r *{{ .Name }}Reconciler) reconcile{{ .Name }}(ctx context.Context, res *{{ .PackageAlias }}.{{ .Name }}) error {
	// TODO: Implement {{ .Name }}-specific reconciliation logic
	//
	// Guidelines:
	//   1. Keep this method idempotent (safe to call multiple times)
	//   2. Update Status to reflect observed state
	//   3. Emit events for significant state changes
	//   4. Use r.Logger for debugging
	//   5. Return errors for transient failures (will retry with backoff)
	//
	// Example:
	//   - For BMC: Connect via Redfish, update Status.Connected, Status.Version
	//   - For Node: Check health, update Status.PowerState, Status.Health
	//   - For FRU: Verify presence, update Status.Present, Status.Health

	r.Logger.Infof("{{ .Name }} reconciliation not yet implemented for %s", res.GetUID())
	
	return nil
}
