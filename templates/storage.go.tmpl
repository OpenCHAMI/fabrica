// Code generated by codegen. DO NOT EDIT.
//
// This file provides high-level storage functions that use the storage interface system.
// The actual storage backend is configurable and can be file-based, database-based, etc.
//
// To modify storage behavior:
//   1. Edit pkg/codegen/templates/storage.go.tmpl
//   2. Run 'make dev' to regenerate
//
// To change storage backend:
//   1. Implement storage.StorageBackend interface
//   2. Update initialization in main.go to use your backend
//
// Current backend: Configurable via DefaultBackend variable
//
package storage

import (
	"context"
	"fmt"
	"sync"

	"{{.ModulePath}}/pkg/resources/bmc"
	"{{.ModulePath}}/pkg/resources/node"
	"{{.ModulePath}}/pkg/resources/fru"
	"{{.ModulePath}}/pkg/resources/boot"
)

// DefaultBackend is the storage backend used by the package-level convenience functions.
// This can be set during application initialization to use any StorageBackend implementation.
//
// Example:
//   // Use file-based storage
//   storage.DefaultBackend, _ = storage.NewFileBackend("./inventory")
//
//   // Use database storage (hypothetical)
//   storage.DefaultBackend = storage.NewDatabaseBackend(dbConfig)
var DefaultBackend StorageBackend

// initOnce ensures DefaultBackend is initialized only once
var initOnce sync.Once

// ensureDefaultBackend initializes DefaultBackend if it hasn't been set
func ensureDefaultBackend() {
	initOnce.Do(func() {
		if DefaultBackend == nil {
			// Default to file-based storage in "inventory" directory
			backend, err := NewFileBackend("inventory")
			if err != nil {
				panic(fmt.Sprintf("failed to initialize default storage backend: %v", err))
			}
			DefaultBackend = backend
		}
	})
}

// Package-level convenience functions for each resource type.
// These functions use the DefaultBackend and provide a simple API
// for applications that don't need to manage multiple backends.

{{range .Resources}}
// {{.Name}} storage operations using DefaultBackend

// LoadAll{{.StorageName}}s retrieves all {{.Name}} resources using the default backend.
//
// Returns:
//   - []{{.TypeName}}: Slice of {{.Name}} resources
//   - error: Any error that occurred during loading
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).LoadAll(ctx).
func LoadAll{{.StorageName}}s() ([]{{.TypeName}}, error) {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.LoadAll(context.Background())
}

// Load{{.StorageName}} retrieves a single {{.Name}} resource by UID using the default backend.
//
// Parameters:
//   - uid: Unique identifier of the {{.Name}} resource
//
// Returns:
//   - {{.TypeName}}: The {{.Name}} resource
//   - error: ErrNotFound if resource doesn't exist, other errors for failures
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).Load(ctx, uid).
func Load{{.StorageName}}(uid string) ({{.TypeName}}, error) {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.Load(context.Background(), uid)
}

// Save{{.StorageName}} stores a {{.Name}} resource using the default backend.
//
// Parameters:
//   - {{camelCase .Name}}: The {{.Name}} resource to save
//
// Returns:
//   - error: Any error that occurred during saving
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).Save(ctx, resource).
func Save{{.StorageName}}({{camelCase .Name}} {{.TypeName}}) error {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.Save(context.Background(), {{camelCase .Name}})
}

// Delete{{.StorageName}} removes a {{.Name}} resource by UID using the default backend.
//
// Parameters:
//   - uid: Unique identifier of the {{.Name}} resource
//
// Returns:
//   - error: ErrNotFound if resource doesn't exist, other errors for failures
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).Delete(ctx, uid).
func Delete{{.StorageName}}(uid string) error {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.Delete(context.Background(), uid)
}

// Exists{{.StorageName}} checks if a {{.Name}} resource exists using the default backend.
//
// Parameters:
//   - uid: Unique identifier of the {{.Name}} resource
//
// Returns:
//   - bool: true if the resource exists
//   - error: Any error that occurred during the check
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).Exists(ctx, uid).
func Exists{{.StorageName}}(uid string) (bool, error) {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.Exists(context.Background(), uid)
}

// List{{.StorageName}}UIDs returns UIDs of all {{.Name}} resources using the default backend.
//
// Returns:
//   - []string: Array of {{.Name}} resource UIDs
//   - error: Any error that occurred during listing
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).List(ctx).
func List{{.StorageName}}UIDs() ([]string, error) {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.List(context.Background())
}

// Load{{.StorageName}}WithVersion retrieves a single {{.Name}} resource in the requested schema version.
//
// Parameters:
//   - uid: Unique identifier of the {{.Name}} resource
//   - version: Requested schema version (e.g., "v1", "v2beta1")
//
// Returns:
//   - interface{}: The {{.Name}} resource in requested version (caller must type assert)
//   - string: Actual version returned
//   - error: ErrNotFound if resource doesn't exist, error if version not supported
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).LoadWithVersion(ctx, uid, version).
//
// Example:
//   resource, version, err := storage.Load{{.StorageName}}WithVersion("{{toLower .Name}}-123", "v2beta1")
//   if err != nil {
//       return err
//   }
//   // Type assert to expected version type
//   if {{camelCase .Name}}V2, ok := resource.(*{{toLower .PackageAlias}}v2beta1.{{.Name}}); ok {
//       // Use v2beta1 resource
//   }
func Load{{.StorageName}}WithVersion(uid string, version string) (interface{}, string, error) {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.LoadWithVersion(context.Background(), uid, version)
}

// LoadAll{{.StorageName}}sWithVersion retrieves all {{.Name}} resources in the requested schema version.
//
// Parameters:
//   - version: Requested schema version (e.g., "v1", "v2beta1")
//
// Returns:
//   - []interface{}: Slice of {{.Name}} resources in requested version
//   - error: Error if version not supported
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).LoadAllWithVersion(ctx, version).
//
// Example:
//   resources, err := storage.LoadAll{{.StorageName}}sWithVersion("v2beta1")
//   if err != nil {
//       return err
//   }
//   for _, r := range resources {
//       if {{camelCase .Name}}V2, ok := r.(*{{toLower .PackageAlias}}v2beta1.{{.Name}}); ok {
//           // Use v2beta1 resource
//       }
//   }
func LoadAll{{.StorageName}}sWithVersion(version string) ([]interface{}, error) {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.LoadAllWithVersion(context.Background(), version)
}

// Save{{.StorageName}}WithVersion stores a {{.Name}} resource with version information.
//
// Parameters:
//   - {{camelCase .Name}}: The {{.Name}} resource to save (can be any supported version)
//   - version: Schema version of the provided resource
//
// Returns:
//   - error: Any error that occurred during saving
//
// The storage backend will convert the resource to the storage version if needed.
//
// This is a convenience function that uses storage.DefaultBackend.
// For more control, use storage.Get{{.Name}}Storage(backend).SaveWithVersion(ctx, resource, version).
func Save{{.StorageName}}WithVersion({{camelCase .Name}} interface{}, version string) error {
	ensureDefaultBackend()
	storage := Get{{.Name}}Storage(DefaultBackend)
	return storage.SaveWithVersion(context.Background(), {{camelCase .Name}}, version)
}

{{end}}

// SetDefaultBackend sets the storage backend used by package-level convenience functions.
//
// Parameters:
//   - backend: The StorageBackend implementation to use
//
// This function should be called during application initialization before
// any storage operations are performed.
//
// Example:
//   backend, err := storage.NewFileBackend("./data")
//   if err != nil {
//       log.Fatal(err)
//   }
//   storage.SetDefaultBackend(backend)
func SetDefaultBackend(backend StorageBackend) {
	DefaultBackend = backend
}

// GetDefaultBackend returns the current default storage backend.
// If no backend has been set, it initializes a file-based backend.
//
// Returns:
//   - StorageBackend: The current default backend
func GetDefaultBackend() StorageBackend {
	ensureDefaultBackend()
	return DefaultBackend
}
