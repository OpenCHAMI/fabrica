// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT

package schema

import (
	"encoding/json"
	"fmt"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/index"
)

// Resource holds the schema definition for the generic resource entity.
// This schema stores Kubernetes-style resources with Spec and Status as JSON.
type Resource struct {
	ent.Schema
}

// Fields of the Resource.
func (Resource) Fields() []ent.Field {
	return []ent.Field{
		// Identity
		field.String("uid").
			Unique().
			Immutable().
			NotEmpty().
			Comment("Unique identifier (e.g., dev-1a2b3c4d)"),

		field.String("name").
			NotEmpty().
			MaxLen(253).
			Comment("Human-readable name"),

		// Resource type information
		field.String("api_version").
			Default("v1").
			Comment("API version (e.g., v1, v2beta1)"),

		field.String("kind").
			NotEmpty().
			Comment("Resource kind (e.g., Device, Node)"),

		field.String("resource_type").
			NotEmpty().
			Comment("Resource type for indexing"),

		// Kubernetes-style Spec and Status (stored as JSON)
		field.JSON("spec", json.RawMessage{}).
			Comment("Desired state of the resource").
			Validate(func(data json.RawMessage) error {
				if len(data) == 0 {
					return fmt.Errorf("spec cannot be empty")
				}
				return nil
			}),

		field.JSON("status", json.RawMessage{}).
			Optional().
			Comment("Observed state of the resource"),

		// Timestamps
		field.Time("created_at").
			Immutable().
			Default(time.Now).
			Comment("Resource creation timestamp"),

		field.Time("updated_at").
			Default(time.Now).
			UpdateDefault(time.Now).
			Comment("Last update timestamp"),

		// Versioning for optimistic concurrency control
		field.String("resource_version").
			Default("1").
			Comment("Resource version for ETags and optimistic locking"),

		// Optional namespace for multi-tenancy
		field.String("namespace").
			Optional().
			Comment("Namespace for multi-tenancy"),
	}
}

// Edges of the Resource.
func (Resource) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("labels", Label.Type).
			Comment("Labels for selection and grouping"),
		edge.To("annotations", Annotation.Type).
			Comment("Annotations for arbitrary metadata"),
	}
}

// Indexes of the Resource.
func (Resource) Indexes() []ent.Index {
	return []ent.Index{
		index.Fields("uid").Unique(),
		index.Fields("resource_type", "name"),
		index.Fields("resource_type", "namespace"),
		index.Fields("kind"),
	}
}
