// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT

package storage

import (
	"context"
	"encoding/json"
	"fmt"

	"{{.ModulePath}}/internal/storage/ent"
	"{{.ModulePath}}/pkg/resource"
	{{range .Resources}}
	{{.PackageAlias}} "{{.Package}}"
	{{end}}
)

// ToEntResource converts a Fabrica resource to an Ent resource entity for storage.
// This function extracts the Resource fields and marshals Spec/Status to JSON.
func ToEntResource(fabricaResource interface{}) (*ent.ResourceCreate, map[string]string, map[string]string, error) {
	// Extract base resource fields
	r, ok := fabricaResource.(interface{ GetUID() string })
	if !ok {
		return nil, nil, nil, fmt.Errorf("resource does not implement GetUID()")
	}

	// Type assertion to get Resource fields
	var apiVersion, kind, name, uid, namespace string
	var spec, status json.RawMessage
	var labels, annotations map[string]string
	var createdAt, updatedAt interface{}

	switch v := fabricaResource.(type) {
	{{range .Resources}}
	case *{{.PackageAlias}}.{{.Name}}:
		apiVersion = v.APIVersion
		kind = v.Kind
		name = v.Metadata.Name
		uid = v.Metadata.UID
		labels = v.Metadata.Labels
		annotations = v.Metadata.Annotations
		createdAt = v.Metadata.CreatedAt
		updatedAt = v.Metadata.UpdatedAt
		if v.Metadata.Namespace != "" {
			namespace = v.Metadata.Namespace
		}

		var err error
		spec, err = json.Marshal(v.Spec)
		if err != nil {
			return nil, nil, nil, fmt.Errorf("failed to marshal spec: %w", err)
		}

		status, err = json.Marshal(v.Status)
		if err != nil {
			return nil, nil, nil, fmt.Errorf("failed to marshal status: %w", err)
		}
	{{end}}
	default:
		return nil, nil, nil, fmt.Errorf("unsupported resource type: %T", fabricaResource)
	}

	// Create Ent entity (return create builder, caller will handle labels/annotations separately)
	create := entClient.Resource.Create().
		SetUID(uid).
		SetName(name).
		SetAPIVersion(apiVersion).
		SetKind(kind).
		SetResourceType(kind).
		SetSpec(spec).
		SetCreatedAt(createdAt.(time.Time)).
		SetUpdatedAt(updatedAt.(time.Time))

	if len(status) > 0 && string(status) != "null" {
		create = create.SetStatus(status)
	}

	if namespace != "" {
		create = create.SetNamespace(namespace)
	}

	return create, labels, annotations, nil
}

// FromEntResource converts an Ent resource entity to a Fabrica resource.
// This function unmarshals the JSON Spec/Status back into typed structs.
func FromEntResource(ctx context.Context, entResource *ent.Resource) (interface{}, error) {
	switch entResource.Kind {
	{{range .Resources}}
	case "{{.Name}}":
		resource := &{{.PackageAlias}}.{{.Name}}{
			Resource: resource.Resource{
				APIVersion: entResource.APIVersion,
				Kind:       entResource.Kind,
				Metadata: resource.Metadata{
					Name:        entResource.Name,
					UID:         entResource.UID,
					CreatedAt:   entResource.CreatedAt,
					UpdatedAt:   entResource.UpdatedAt,
					Labels:      make(map[string]string),
					Annotations: make(map[string]string),
				},
			},
		}

		if entResource.Namespace != nil {
			resource.Metadata.Namespace = *entResource.Namespace
		}

		// Unmarshal Spec
		if err := json.Unmarshal(entResource.Spec, &resource.Spec); err != nil {
			return nil, fmt.Errorf("failed to unmarshal spec for {{.Name}}: %w", err)
		}

		// Unmarshal Status
		if len(entResource.Status) > 0 && string(entResource.Status) != "null" {
			if err := json.Unmarshal(entResource.Status, &resource.Status); err != nil {
				return nil, fmt.Errorf("failed to unmarshal status for {{.Name}}: %w", err)
			}
		}

		// Load labels from edges
		if entResource.Edges.Labels != nil {
			for _, label := range entResource.Edges.Labels {
				resource.Metadata.Labels[label.Key] = label.Value
			}
		}

		// Load annotations from edges
		if entResource.Edges.Annotations != nil {
			for _, ann := range entResource.Edges.Annotations {
				resource.Metadata.Annotations[ann.Key] = ann.Value
			}
		}

		return resource, nil
	{{end}}
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", entResource.Kind)
	}
}

// saveLabels saves or updates labels for a resource
func saveLabels(ctx context.Context, resourceID int, labels map[string]string) error {
	// Delete existing labels
	_, err := entClient.Label.Delete().
		Where(label.HasResourceWith(resourceEnt.IDEQ(resourceID))).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to delete old labels: %w", err)
	}

	// Create new labels
	for key, value := range labels {
		_, err := entClient.Label.Create().
			SetKey(key).
			SetValue(value).
			SetResourceID(resourceID).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create label %s=%s: %w", key, value, err)
		}
	}

	return nil
}

// saveAnnotations saves or updates annotations for a resource
func saveAnnotations(ctx context.Context, resourceID int, annotations map[string]string) error {
	// Delete existing annotations
	_, err := entClient.Annotation.Delete().
		Where(annotation.HasResourceWith(resourceEnt.IDEQ(resourceID))).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to delete old annotations: %w", err)
	}

	// Create new annotations
	for key, value := range annotations {
		_, err := entClient.Annotation.Create().
			SetKey(key).
			SetValue(value).
			SetResourceID(resourceID).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create annotation %s: %w", key, err)
		}
	}

	return nil
}
