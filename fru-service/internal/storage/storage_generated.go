// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides storage functions using Ent as the backend.
// The functions maintain the same interface as file storage for compatibility.

package storage

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/openchami/fru-service/internal/storage/ent"
	"github.com/openchami/fru-service/internal/storage/ent/resource"

	fru "github.com/openchami/fru-service/pkg/resources/fru"
)

// ErrNotFound indicates that a resource was not found
var ErrNotFound = errors.New("resource not found")

// Ent client (initialized in main.go)
var entClient *ent.Client

// SetEntClient sets the Ent client for storage operations
func SetEntClient(client *ent.Client) {
	entClient = client
}

// LoadAllFRUs loads all FRU resources from Ent storage
func LoadAllFRUs(ctx context.Context) ([]*fru.FRU, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(resource.KindEQ("FRU")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load FRU resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*fru.FRU
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*fru.FRU))
	}

	return resources, nil
}

// LoadFRU loads a single FRU resource by UID from Ent storage
func LoadFRU(ctx context.Context, uid string) (*fru.FRU, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			resource.UidEQ(uid),
			resource.KindEQ("FRU"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load FRU %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*fru.FRU), nil
}

// SaveFRU saves a FRU resource to Ent storage
func SaveFRU(ctx context.Context, resource *fru.FRU) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert FRU to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(resource.UidEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check FRU existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create FRU: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update FRU: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// DeleteFRU deletes a FRU resource from Ent storage
func DeleteFRU(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			resource.UidEQ(uid),
			resource.KindEQ("FRU"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete FRU %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}
