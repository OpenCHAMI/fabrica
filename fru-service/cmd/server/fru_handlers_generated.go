// Code generated by codegen. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file contains REST API handlers for FRU resources.
// Generated from: pkg/codegen/templates/handlers.go.tmpl
//
// To modify this code:
//  1. Edit the template file: pkg/codegen/templates/handlers.go.tmpl
//  2. Run 'make dev' to regenerate
//  3. Do NOT edit this file directly - changes will be lost
//
// Generated handlers provide:
//   - GET /frus (list all frus)
//   - GET /frus/{uid} (get specific FRU)
//   - POST /frus (create new FRU)
//   - PUT /frus/{uid} (update FRU)
//   - DELETE /frus/{uid} (delete FRU)
//
// Authentication: DISABLED
// Storage: Uses storage.LoadFRU*/SaveFRU*/DeleteFRU*
// Version Support: Available (see version context in handlers)
//
// To enable full version conversion for this resource:
//  1. Create v2beta1 package: pkg/resources/fru/v2beta1/
//  2. Implement converter: v2beta1/converter.go
//  3. Add version-aware storage: storage.LoadFRUWithVersion()
//  4. Register versions in cmd/server/main.go
package main

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/alexlovelltroy/fabrica/pkg/resource"
	"github.com/alexlovelltroy/fabrica/pkg/validation"
	"github.com/alexlovelltroy/fabrica/pkg/versioning"
	"github.com/go-chi/chi/v5"
	"github.com/openchami/fru-service/internal/storage"
	"github.com/openchami/fru-service/pkg/resources/fru"
)

// GetFRUs returns all FRU resources
func GetFRUs(w http.ResponseWriter, r *http.Request) {

	frus, err := storage.LoadAllFRUs()
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to load frus: %w", err))
		return
	}
	respondJSON(w, http.StatusOK, frus)
}

// GetFRU returns a specific FRU resource by UID
func GetFRU(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("FRU UID is required"))
		return
	}

	// Version context available here for version-aware operations
	// versionCtx := versioning.GetVersionContext(r.Context())
	// Requested version: versionCtx.ServeVersion
	// To enable: replace storage.LoadFRU() with version-aware function

	fRU, err := storage.LoadFRU(uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("FRU not found: %w", err))
		return
	}
	respondJSON(w, http.StatusOK, fRU)
}

// CreateFRU creates a new FRU resource
func CreateFRU(w http.ResponseWriter, r *http.Request) {
	var req CreateFRURequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// Get version context from request
	versionCtx := versioning.GetVersionContext(r.Context())

	uid, err := resource.GenerateUIDForResource("FRU")
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to generate UID: %w", err))
		return
	}

	fRU := &fru.FRU{
		Resource: resource.Resource{
			APIVersion:    versionCtx.GroupVersion,
			Kind:          "FRU",
			SchemaVersion: versionCtx.ServeVersion,
		},
		Spec: req.FRUSpec,
	}

	fRU.Metadata.Initialize(req.Name, uid)

	// Set labels and annotations
	for k, v := range req.Labels {
		fRU.SetLabel(k, v)
	}
	for k, v := range req.Annotations {
		fRU.SetAnnotation(k, v)
	}

	// Layer 2: Fabrica struct tag validation
	if err := validation.ValidateResource(fRU); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	// Layer 3: Custom business logic validation
	if err := validation.ValidateWithContext(r.Context(), fRU); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	// Set initial status

	// Save (Layer 1: Ent validation happens automatically if using Ent storage)
	if err := storage.SaveFRU(fRU); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save FRU: %w", err))
		return
	}

	respondJSON(w, http.StatusCreated, fRU)
}

// UpdateFRU updates an existing FRU resource
func UpdateFRU(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("FRU UID is required"))
		return
	}

	fRU, err := storage.LoadFRU(uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("FRU not found: %w", err))
		return
	}

	var req UpdateFRURequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// Apply updates
	if req.Name != "" {
		fRU.SetName(req.Name)
	}

	// Update spec fields - merge non-zero values from request
	fRU.Spec = req.FRUSpec

	// Update labels and annotations
	for k, v := range req.Labels {
		fRU.SetLabel(k, v)
	}
	for k, v := range req.Annotations {
		fRU.SetAnnotation(k, v)
	}

	fRU.Touch()

	if err := storage.SaveFRU(fRU); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save FRU: %w", err))
		return
	}

	respondJSON(w, http.StatusOK, fRU)
}

// DeleteFRU deletes a FRU resource
func DeleteFRU(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("FRU UID is required"))
		return
	}

	if err := storage.DeleteFRU(uid); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to delete FRU: %w", err))
		return
	}

	respondJSON(w, http.StatusOK, &DeleteResponse{
		Message: "FRU deleted successfully",
		UID:     uid,
	})
}
