/*
 * Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
 *
 * SPDX-License-Identifier: MIT
 */

// Code generated by fabrica. DO NOT EDIT.
package server

import (
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"strconv"
	"strings"

	"github.com/alexlovelltroy/fabrica/pkg/versioning"
)

// VersionStrategy defines how API versions are negotiated
// Configured in .fabrica.yaml: {{.VersionStrategy}}
const VersionStrategy = "{{.VersionStrategy}}" // header, url, both

// SupportedVersions lists all API versions supported by this server
var SupportedVersions = []int{1}

// DefaultVersion is the version used when none is specified
const DefaultVersion = 1

// VersioningMiddleware handles API version negotiation
//
// Strategies:
//   - header: Uses Accept header (application/vnd.myapp.v1+json)
//   - url: Uses URL prefix (/v1/resources)
//   - both: Supports both strategies, header takes precedence
//
// Sets request context with:
//   - "api-version": int (requested version)
func VersioningMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var version int
		var err error

		switch VersionStrategy {
		case "header":
			version, err = extractVersionFromHeader(r)
		case "url":
			version, err = extractVersionFromURL(r)
		case "both":
			// Try header first, fall back to URL
			version, err = extractVersionFromHeader(r)
			if err != nil || version == 0 {
				version, err = extractVersionFromURL(r)
			}
		default:
			version = DefaultVersion
		}

		if err != nil {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error": "Invalid API version",
				"message": err.Error(),
				"supported_versions": SupportedVersions,
			})
			return
		}

		// Use default if no version specified
		if version == 0 {
			version = DefaultVersion
		}

		// Validate version is supported
		if !isVersionSupported(version) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusNotAcceptable)
			json.NewEncoder(w).Encode(map[string]interface{}{
				"error": "Unsupported API version",
				"requested_version": version,
				"supported_versions": SupportedVersions,
			})
			return
		}

		// Set version in context
		ctx := versioning.WithVersion(r.Context(), version)
		r = r.WithContext(ctx)

		// Set version header in response
		w.Header().Set("X-API-Version", fmt.Sprintf("%d", version))

		next.ServeHTTP(w, r)
	})
}

// extractVersionFromHeader parses version from Accept header
// Format: Accept: application/vnd.myapp.v1+json
func extractVersionFromHeader(r *http.Request) (int, error) {
	accept := r.Header.Get("Accept")
	if accept == "" {
		return 0, nil // No version specified
	}

	// Parse Accept header for version
	// Matches: application/vnd.*.v<number>+json
	re := regexp.MustCompile(`application/vnd\.[^.]+\.v(\d+)\+json`)
	matches := re.FindStringSubmatch(accept)

	if len(matches) < 2 {
		// Try simple application/json (use default)
		if strings.Contains(accept, "application/json") {
			return 0, nil
		}
		return 0, fmt.Errorf("invalid Accept header format: %s", accept)
	}

	version, err := strconv.Atoi(matches[1])
	if err != nil {
		return 0, fmt.Errorf("invalid version number: %s", matches[1])
	}

	return version, nil
}

// extractVersionFromURL parses version from URL path
// Format: /v1/resources or /api/v1/resources
func extractVersionFromURL(r *http.Request) (int, error) {
	path := r.URL.Path

	// Match /v<number>/ or /api/v<number>/
	re := regexp.MustCompile(`^(?:/api)?/v(\d+)/`)
	matches := re.FindStringSubmatch(path)

	if len(matches) < 2 {
		return 0, nil // No version in URL
	}

	version, err := strconv.Atoi(matches[1])
	if err != nil {
		return 0, fmt.Errorf("invalid version number in URL: %s", matches[1])
	}

	return version, nil
}

// isVersionSupported checks if the requested version is supported
func isVersionSupported(version int) bool {
	for _, v := range SupportedVersions {
		if v == version {
			return true
		}
	}
	return false
}

// GetVersionFromContext retrieves the API version from request context
func GetVersionFromContext(r *http.Request) int {
	if version := versioning.GetVersion(r.Context()); version != 0 {
		return version
	}
	return DefaultVersion
}

// VersionDeprecatedWarning adds deprecation warning header
func VersionDeprecatedWarning(w http.ResponseWriter, version int, sunsetDate string) {
	w.Header().Set("X-API-Deprecation", fmt.Sprintf("Version %d is deprecated", version))
	if sunsetDate != "" {
		w.Header().Set("Sunset", sunsetDate)
	}
	w.Header().Set("Link", `</docs/migration>; rel="deprecation"`)
}
