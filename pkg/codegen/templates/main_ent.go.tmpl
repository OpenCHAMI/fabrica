// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT

package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/alexlovelltroy/fabrica/pkg/events"
	"{{.ModulePath}}/internal/storage"
	"{{.ModulePath}}/internal/storage/ent"
	"{{.ModulePath}}/internal/storage/ent/migrate"

	{{if eq .DBDriver "postgres"}}
	_ "github.com/lib/pq"
	{{else if eq .DBDriver "mysql"}}
	_ "github.com/go-sql-driver/mysql"
	{{else if eq .DBDriver "sqlite"}}
	_ "github.com/mattn/go-sqlite3"
	{{end}}
)

func main() {
	// Get database URL from environment
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		{{if eq .DBDriver "sqlite"}}
		dbURL = "file:./data.db?cache=shared&_fk=1"
		log.Println("DATABASE_URL not set, using default SQLite: ./data.db")
		{{else if eq .DBDriver "postgres"}}
		dbURL = "postgres://localhost/{{.ProjectName}}?sslmode=disable"
		log.Println("DATABASE_URL not set, using default: postgres://localhost/{{.ProjectName}}")
		{{else if eq .DBDriver "mysql"}}
		dbURL = "root:@tcp(localhost:3306)/{{.ProjectName}}?parseTime=true"
		log.Println("DATABASE_URL not set, using default MySQL")
		{{end}}
	}

	// Open Ent client
	client, err := ent.Open("{{.DBDriver}}", dbURL)
	if err != nil {
		log.Fatalf("failed opening connection to {{.DBDriver}}: %v", err)
	}
	defer client.Close()

	// Run auto-migration
	ctx := context.Background()
	if err := client.Schema.Create(
		ctx,
		migrate.WithDropIndex(true),
		migrate.WithDropColumn(true),
	); err != nil {
		log.Fatalf("failed creating schema resources: %v", err)
	}
	log.Println("Database schema migrated successfully")

	// Set Ent client for storage operations
	storage.SetEntClient(client)

	// Initialize event system with configuration from environment
	config := events.EventConfig{
		EventTypePrefix:        os.Getenv("EVENT_TYPE_PREFIX"),        // Default: "" (disabled)
		LifecycleEventsEnabled: os.Getenv("LIFECYCLE_EVENTS_ENABLED") == "true", // Default: false
		ConditionEventsEnabled: os.Getenv("CONDITION_EVENTS_ENABLED") == "true", // Default: false
	}

	// If no prefix is set but events are enabled, use a default
	if (config.LifecycleEventsEnabled || config.ConditionEventsEnabled) && config.EventTypePrefix == "" {
		config.EventTypePrefix = "{{.ProjectName}}.resource"
		log.Println("Event publishing enabled with default prefix:", config.EventTypePrefix)
	}

	// Initialize event configuration
	events.SetEventConfig(config)

	// Initialize event bridge for condition events (if needed by your resources)
	events.InitializeEventBridge()

	log.Printf("Event system initialized - Lifecycle: %v, Conditions: %v, Prefix: %s",
		config.LifecycleEventsEnabled, config.ConditionEventsEnabled, config.EventTypePrefix)

	// Register routes
	mux := http.NewServeMux()
	RegisterRoutes(mux)

	// Create server
	server := &http.Server{
		Addr:         ":8080",
		Handler:      mux,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	// Start server in goroutine
	go func() {
		log.Printf("Server starting on %s", server.Addr)
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Server failed: %v", err)
		}
	}()

	// Wait for interrupt signal to gracefully shut down
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Server shutting down...")

	// Graceful shutdown with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server exited")
}
