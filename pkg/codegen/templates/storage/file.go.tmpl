// Code generated by fabrica generate. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides storage convenience functions for your resources.
// It uses the fabrica storage backend system.
//
// To modify storage behavior:
//   1. Edit pkg/codegen/templates/storage.go.tmpl
//   2. Run 'fabrica generate' to regenerate
//
// To change storage backend:
//   1. Call storage.Init() with a different backend in main.go
//   2. Options: FileBackend, EntBackend (database), or custom backend
//
package storage

{{/* Determine if any resource has versioning enabled to gate extra imports */}}
{{$hasVersioning := false}}
{{range .Resources}}{{if .Tags}}{{if eq (index .Tags "versioning") "enabled"}}
{{$hasVersioning = true}}{{end}}{{end}}{{end}}

import (
	"context"
	"encoding/json"
	"fmt"
{{if $hasVersioning}}	"os"{{end}}
{{if $hasVersioning}}	"path/filepath"{{end}}
{{if $hasVersioning}}	"strings"{{end}}
{{if $hasVersioning}}	"time"{{end}}
{{if $hasVersioning}}	"sort"{{end}}

	fabricaStorage "github.com/openchami/fabrica/pkg/storage"
	"github.com/openchami/fabrica/pkg/reconcile"
{{range .Resources}}
	"{{.Package}}"
{{- end}}
)

// Backend is the storage backend used by all storage operations.
// Initialize this in your main.go before using any storage functions.
//
// Example:
//   backend, err := fabricaStorage.NewFileBackend("./data")
//   if err != nil {
//       log.Fatal(err)
//   }
//   storage.Init(backend)
var Backend fabricaStorage.StorageBackend

// Init initializes the storage backend.
// This must be called before using any storage functions.
func Init(backend fabricaStorage.StorageBackend) {
	Backend = backend
}

// InitFileBackend is a convenience function to initialize file-based storage.
// It creates the directory if it doesn't exist.
func InitFileBackend(dataDir string) error {
	backend, err := fabricaStorage.NewFileBackend(dataDir)
	if err != nil {
		return fmt.Errorf("failed to create file backend: %w", err)
	}
	Backend = backend
	return nil
}

// ensureBackend panics if Backend is not initialized.
// This is called by all storage functions to ensure proper initialization.
func ensureBackend() {
	if Backend == nil {
		panic("storage backend not initialized: call storage.Init() or storage.InitFileBackend() in main.go")
	}
}

{{range .Resources}}
// {{.Name}} storage operations

// LoadAll{{.StorageName}}s retrieves all {{.Name}} resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []{{.TypeName}}: Slice of {{.Name}} resources
//   - error: Any error that occurred during loading
func LoadAll{{.StorageName}}s(ctx context.Context) ([]{{.TypeName}}, error) {
	ensureBackend()

	rawData, err := Backend.LoadAll(ctx, "{{.Name}}")
	if err != nil {
		return nil, fmt.Errorf("failed to load all {{.PluralName}}: %w", err)
	}

	{{camelCase .PluralName}} := make([]{{.TypeName}}, 0, len(rawData))
	for _, raw := range rawData {
		{{camelCase .Name}} := &{{.PackageAlias}}.{{.Name}}{}
		if err := json.Unmarshal(raw, {{camelCase .Name}}); err != nil {
			return nil, fmt.Errorf("failed to unmarshal {{.Name}}: %w", err)
		}
		{{camelCase .PluralName}} = append({{camelCase .PluralName}}, {{camelCase .Name}})
	}

	return {{camelCase .PluralName}}, nil
}

// Load{{.StorageName}} retrieves a single {{.Name}} resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the {{.Name}} resource
//
// Returns:
//   - {{.TypeName}}: The {{.Name}} resource
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func Load{{.StorageName}}(ctx context.Context, uid string) ({{.TypeName}}, error) {
	ensureBackend()

	rawData, err := Backend.Load(ctx, "{{.Name}}", uid)
	if err != nil {
		return nil, fmt.Errorf("failed to load {{.Name}} %s: %w", uid, err)
	}

	{{camelCase .Name}} := &{{.PackageAlias}}.{{.Name}}{}
	if err := json.Unmarshal(rawData, {{camelCase .Name}}); err != nil {
		return nil, fmt.Errorf("failed to unmarshal {{.Name}}: %w", err)
	}

	return {{camelCase .Name}}, nil
}

// Save{{.StorageName}} stores a {{.Name}} resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - {{camelCase .Name}}: The {{.Name}} resource to save
//
// Returns:
//   - error: Any error that occurred during saving
func Save{{.StorageName}}(ctx context.Context, {{camelCase .Name}} {{.TypeName}}) error {
	ensureBackend()

	data, err := json.Marshal({{camelCase .Name}})
	if err != nil {
		return fmt.Errorf("failed to marshal {{.Name}}: %w", err)
	}

	if err := Backend.Save(ctx, "{{.Name}}", {{camelCase .Name}}.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to save {{.Name}}: %w", err)
	}

	return nil
}

// Update{{.StorageName}} updates an existing {{.Name}} resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - {{camelCase .Name}}: The {{.Name}} resource to update
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func Update{{.StorageName}}(ctx context.Context, {{camelCase .Name}} {{.TypeName}}) error {
	ensureBackend()

	// Check if resource exists first
	exists, err := Backend.Exists(ctx, "{{.Name}}", {{camelCase .Name}}.Metadata.UID)
	if err != nil {
		return fmt.Errorf("failed to check {{.Name}} existence: %w", err)
	}
	if !exists {
		return fabricaStorage.ErrNotFound
	}

	data, err := json.Marshal({{camelCase .Name}})
	if err != nil {
		return fmt.Errorf("failed to marshal {{.Name}}: %w", err)
	}

	if err := Backend.Save(ctx, "{{.Name}}", {{camelCase .Name}}.Metadata.UID, data); err != nil {
		return fmt.Errorf("failed to update {{.Name}}: %w", err)
	}

	return nil
}

// Delete{{.StorageName}} removes a {{.Name}} resource by UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the {{.Name}} resource
//
// Returns:
//   - error: fabricaStorage.ErrNotFound if resource doesn't exist, other errors for failures
func Delete{{.StorageName}}(ctx context.Context, uid string) error {
	ensureBackend()

	if err := Backend.Delete(ctx, "{{.Name}}", uid); err != nil {
		return fmt.Errorf("failed to delete {{.Name}} %s: %w", uid, err)
	}

	{{- if .Tags }}{{- if eq (index .Tags "versioning") "enabled" }}
	// Best-effort: remove versions directory for this resource
	_ = delete{{.Name}}VersionsDir(uid)
	{{- end }}{{- end }}

	return nil
}

// Exists{{.StorageName}} checks if a {{.Name}} resource exists.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - uid: Unique identifier of the {{.Name}} resource
//
// Returns:
//   - bool: true if the resource exists
//   - error: Any error that occurred during the check
func Exists{{.StorageName}}(ctx context.Context, uid string) (bool, error) {
	ensureBackend()

	exists, err := Backend.Exists(ctx, "{{.Name}}", uid)
	if err != nil {
		return false, fmt.Errorf("failed to check {{.Name}} existence: %w", err)
	}

	return exists, nil
}

// List{{.StorageName}}UIDs returns UIDs of all {{.Name}} resources.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//
// Returns:
//   - []string: Array of {{.Name}} resource UIDs
//   - error: Any error that occurred during listing
func List{{.StorageName}}UIDs(ctx context.Context) ([]string, error) {
	ensureBackend()

	uids, err := Backend.List(ctx, "{{.Name}}")
	if err != nil {
		return nil, fmt.Errorf("failed to list {{.Name}} UIDs: %w", err)
	}

	return uids, nil
}

{{end}}

// StorageClient wraps a StorageBackend to implement reconcile.ClientInterface.
//
// This adapter allows reconcilers to use the storage backend through a
// standard interface that provides typed resource access.
type StorageClient struct {
	backend fabricaStorage.StorageBackend
}

// Compile-time check that StorageClient implements reconcile.ClientInterface
var _ reconcile.ClientInterface = (*StorageClient)(nil)

// NewStorageClient creates a new storage client that wraps the configured backend.
//
// This is used by the reconciliation system to provide reconcilers with
// access to resource storage.
//
// Returns:
//   - *StorageClient: Client that implements reconcile.ClientInterface
func NewStorageClient() *StorageClient {
	ensureBackend()
	return &StorageClient{backend: Backend}
}

// --- Version snapshot helpers (file backend only) ---
{{range .Resources}}{{if .Tags}}{{if eq (index .Tags "versioning") "enabled"}}

// {{.Name}}VersionSnapshot represents a stored version of a {{.Name}}'s spec
type {{.Name}}VersionSnapshot struct {
	VersionID string                 `json:"versionId"`
	CreatedAt time.Time              `json:"createdAt"`
	UID       string                 `json:"uid"`
	Name      string                 `json:"name"`
	Labels    map[string]string      `json:"labels,omitempty"`
	Annotations map[string]string    `json:"annotations,omitempty"`
	Spec      {{.SpecType}}          `json:"spec"`
}

func versionsBaseDir() string {
	// Attempt to derive file backend base dir by introspection isn't available here;
	// Instead, infer from environment variable or default to ./data like main.go template.
	// Generated projects typically call storage.InitFileBackend("./data").
	// We'll construct paths relative to that default.
	return "./data"
}

func {{toLower .Name}}VersionsDir() string {
	return filepath.Join(versionsBaseDir(), "{{.PluralName}}", "versions")
}

func delete{{.Name}}VersionsDir(uid string) error {
	dir := filepath.Join({{toLower .Name}}VersionsDir(), uid)
	return os.RemoveAll(dir)
}

// Create{{.Name}}VersionSnapshot saves a new version snapshot for the given resource and returns the new VersionID
func Create{{.Name}}VersionSnapshot(ctx context.Context, res {{.TypeName}}) (string, error) {
	// Build snapshot (no status)
	snap := {{.Name}}VersionSnapshot{
		VersionID: generateULID(),
		CreatedAt: time.Now().UTC(),
		UID:       res.Metadata.UID,
		Name:      res.Metadata.Name,
		Labels:    res.Metadata.Labels,
		Annotations: res.Metadata.Annotations,
	}
	if spec, ok := any(res.Spec).({{.SpecType}}); ok {
		snap.Spec = spec
	} else {
		// Best-effort JSON roundtrip to map then back into spec type when possible
		// If it fails, store empty spec rather than erroring save path
		// Note: generated specs are concrete types, so this usually succeeds
		var tmp {{.SpecType}}
		b, _ := json.Marshal(res.Spec)
		_ = json.Unmarshal(b, &tmp)
		snap.Spec = tmp
	}

	// Serialize
	data, err := json.MarshalIndent(snap, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal snapshot: %w", err)
	}

	// Write to file: data/<plural>/versions/<uid>/<versionId>.json
	dir := filepath.Join({{toLower .Name}}VersionsDir(), res.Metadata.UID)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return "", fmt.Errorf("failed to create versions dir: %w", err)
	}
	path := filepath.Join(dir, snap.VersionID+".json")
	if err := os.WriteFile(path, data, 0644); err != nil {
		return "", fmt.Errorf("failed to write version file: %w", err)
	}
	return snap.VersionID, nil
}

// List{{.Name}}Versions lists version snapshots (metadata) for a resource
func List{{.Name}}Versions(ctx context.Context, uid string) ([]{{.Name}}VersionSnapshot, error) {
	dir := filepath.Join({{toLower .Name}}VersionsDir(), uid)
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []{{.Name}}VersionSnapshot{}, nil
		}
		return nil, fmt.Errorf("failed to read versions dir: %w", err)
	}

	var out []{{.Name}}VersionSnapshot
	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".json") {
			continue
		}
		b, err := os.ReadFile(filepath.Join(dir, e.Name()))
		if err != nil {
			continue
		}
		var snap {{.Name}}VersionSnapshot
		if err := json.Unmarshal(b, &snap); err != nil {
			continue
		}
		out = append(out, snap)
	}
	return out, nil
}

// Get{{.Name}}Version loads a specific version snapshot
func Get{{.Name}}Version(ctx context.Context, uid, versionID string) (*{{.Name}}VersionSnapshot, error) {
	path := filepath.Join({{toLower .Name}}VersionsDir(), uid, versionID+".json")
	b, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("version not found")
		}
		return nil, fmt.Errorf("failed to read version: %w", err)
	}
	var snap {{.Name}}VersionSnapshot
	if err := json.Unmarshal(b, &snap); err != nil {
		return nil, fmt.Errorf("failed to parse version: %w", err)
	}
	return &snap, nil
}

// Delete{{.Name}}Version removes a specific version snapshot
func Delete{{.Name}}Version(ctx context.Context, uid, versionID string) error {
	path := filepath.Join({{toLower .Name}}VersionsDir(), uid, versionID+".json")
	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("failed to delete version: %w", err)
	}
	return nil
}

// generateULID creates a lexicographically sortable unique id
func generateULID() string {
	// Simple ULID substitute using time + random; replace with real ULID if desired in future
	// We avoid adding a dependency in generated projects for simplicity.
	// Format: yyyymmddhhmmss-nanots
	return time.Now().UTC().Format("20060102150405") + fmt.Sprintf("-%d", time.Now().UTC().UnixNano())
}

// Latest{{.Name}}VersionID returns the most recent VersionID for a resource, or empty if none
func Latest{{.Name}}VersionID(ctx context.Context, uid string) (string, error) {
	dir := filepath.Join({{toLower .Name}}VersionsDir(), uid)
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return "", nil
		}
		return "", fmt.Errorf("failed to read versions dir: %w", err)
	}
	var names []string
	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".json") {
			continue
		}
		names = append(names, e.Name())
	}
	if len(names) == 0 {
		return "", nil
	}
	sort.Strings(names)
	latest := strings.TrimSuffix(names[len(names)-1], ".json")
	return latest, nil
}

// Get{{.Name}}LatestVersionID returns the most recent snapshot version ID for a resource (empty if none)
func Get{{.Name}}LatestVersionID(ctx context.Context, uid string) (string, error) {
	versions, err := List{{.Name}}Versions(ctx, uid)
	if err != nil {
		return "", err
	}
	if len(versions) == 0 {
		return "", nil
	}
	latest := versions[0].VersionID
	for _, v := range versions[1:] {
		if v.VersionID > latest { // lexicographically sortable IDs
			latest = v.VersionID
		}
	}
	return latest, nil
}
{{end}}{{end}}{{end}}

// Get retrieves a resource by kind and UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind (e.g., "Device", "Rack")
//   - uid: Unique identifier
//
// Returns:
//   - interface{}: The resource (type-specific)
//   - error: Any error that occurred
func (c *StorageClient) Get(ctx context.Context, kind, uid string) (interface{}, error) {
	rawData, err := c.backend.Load(ctx, kind, uid)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
{{- range .Resources}}
	case "{{.Name}}":
		var resource {{.PackageAlias}}.{{.Name}}
		if err := json.Unmarshal(rawData, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal {{.Name}}: %w", err)
		}
		return &resource, nil
{{- end}}
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

// List retrieves all resources of a given kind.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind (e.g., "Device", "Rack")
//
// Returns:
//   - []interface{}: Slice of resources
//   - error: Any error that occurred
func (c *StorageClient) List(ctx context.Context, kind string) ([]interface{}, error) {
	rawData, err := c.backend.LoadAll(ctx, kind)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
{{- range .Resources}}
	case "{{.Name}}":
		result := make([]interface{}, 0, len(rawData))
		for _, raw := range rawData {
			var resource {{.PackageAlias}}.{{.Name}}
			if err := json.Unmarshal(raw, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal {{.Name}}: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
{{- end}}
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

// Update updates an existing resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The resource to update
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Update(ctx context.Context, resource interface{}) error {
	data, err := json.Marshal(resource)
	if err != nil {
		return fmt.Errorf("failed to marshal resource: %w", err)
	}

	// Extract kind and UID based on type
	switch res := resource.(type) {
{{- range .Resources}}
	case *{{.PackageAlias}}.{{.Name}}:
		return c.backend.Save(ctx, "{{.Name}}", res.Metadata.UID, data)
{{- end}}
	default:
		return fmt.Errorf("unknown resource type: %T", resource)
	}
}

// Create creates a new resource.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - resource: The resource to create
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Create(ctx context.Context, resource interface{}) error {
	// For storage backend, Create is the same as Update (Save handles both)
	return c.Update(ctx, resource)
}

// Delete deletes a resource by kind and UID.
//
// Parameters:
//   - ctx: Context for cancellation and timeouts
//   - kind: Resource kind
//   - uid: Unique identifier
//
// Returns:
//   - error: Any error that occurred
func (c *StorageClient) Delete(ctx context.Context, kind, uid string) error {
	return c.backend.Delete(ctx, kind, uid)
}
