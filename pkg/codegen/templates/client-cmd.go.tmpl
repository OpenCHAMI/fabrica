// Code generated by codegen. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides a Cobra-based CLI for the {{.ProjectName}} API.
// Generated from: pkg/codegen/templates/client-cmd.go.tmpl
//
// To modify the CLI:
//   1. Edit the template file: pkg/codegen/templates/client-cmd.go.tmpl
//   2. Run 'make generate-client-cmd' to regenerate
//   3. Do NOT edit this file directly - changes will be lost
//
// Generated commands for each resource:
{{range .Resources}}//   - client {{toLower .Name}} [list|get|create|update|delete]
{{end}}//
// Global flags (available for all commands):
//   --server       Server URL (env: {{toUpper .ProjectName}}_SERVER)
//   --timeout      Request timeout (env: {{toUpper .ProjectName}}_TIMEOUT)
//   --output, -o   Output format: table, json, yaml (env: {{toUpper .ProjectName}}_OUTPUT)
//   --version, -v  API version to request: v1, v2beta1, etc. (env: {{toUpper .ProjectName}}_VERSION)
//   --config       Config file path (default: ~/.{{.ProjectName}}-cli.yaml)
//
// Configuration sources (in order of precedence):
//   1. Command-line flags
//   2. Environment variables ({{toUpper .ProjectName}}_*)
//   3. Config file (~/.{{.ProjectName}}-cli.yaml)
//   4. Default values
//
// Usage examples:
{{if .Resources}}//   # List all {{(index .Resources 0).PluralName}} (default version)
//   client {{toLower (index .Resources 0).Name}} list
//
//   # List {{(index .Resources 0).PluralName}} with specific version
//   client {{toLower (index .Resources 0).Name}} list --version v2beta1
//
//   # Get {{(index .Resources 0).Name}} as v1
//   client {{toLower (index .Resources 0).Name}} get <uid> --version v1
//
//   # Create from JSON file with version
//   cat {{toLower (index .Resources 0).Name}}.json | client {{toLower (index .Resources 0).Name}} create --version v2beta1
//
//   # Create from inline JSON
//   client {{toLower (index .Resources 0).Name}} create --spec '{"name":"{{toLower (index .Resources 0).Name}}-01","description":"Example {{(index .Resources 0).Name}}"}'
//
//   # Use environment variables
//   export {{toUpper .ProjectName}}_SERVER=https://{{.ProjectName}}.example.com
//   export {{toUpper .ProjectName}}_VERSION=v2beta1
//   client {{toLower (index .Resources 0).Name}} list{{else}}//   # Use environment variables
//   export {{toUpper .ProjectName}}_SERVER=https://{{.ProjectName}}.example.com
//   export {{toUpper .ProjectName}}_VERSION=v2beta1
//   client resource list{{end}}
//
// To add custom commands:
//   1. Add command definition in template after resource commands
//   2. Register it in init() function
//
// To change output formatting:
//   1. Modify printOutput function to add new formats
//   2. Update output flag validation
//
// To add authentication:
//   1. Add auth flags (--token, --username, etc.)
//   2. Modify getClient to configure auth in http.Client
//   3. Add auth headers in client package
//
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"{{.ModulePath}}/pkg/client"
)

var (
	cfgFile    string
	serverURL  string
	timeout    time.Duration
	output     string
	apiVersion string
)

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

var rootCmd = &cobra.Command{
	Use:   filepath.Base(os.Args[0]),
	Short: "{{.ProjectName}} CLI",
	Long:  `A command-line interface for managing {{.ProjectName}} resources.`,
}

func init() {
	cobra.OnInitialize(initConfig)

	// Global flags
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.{{.ProjectName}}-cli.yaml)")
	rootCmd.PersistentFlags().StringVar(&serverURL, "server", "http://localhost:8080", "{{.ProjectName}} server URL")
	rootCmd.PersistentFlags().DurationVar(&timeout, "timeout", 30*time.Second, "request timeout")
	rootCmd.PersistentFlags().StringVarP(&output, "output", "o", "table", "output format: table, json, yaml")
	rootCmd.PersistentFlags().StringVarP(&apiVersion, "version", "v", "", "API version to request (e.g., v1, v2beta1)")

	// Bind flags to viper
	viper.BindPFlag("server", rootCmd.PersistentFlags().Lookup("server"))
	viper.BindPFlag("timeout", rootCmd.PersistentFlags().Lookup("timeout"))
	viper.BindPFlag("output", rootCmd.PersistentFlags().Lookup("output"))
	viper.BindPFlag("version", rootCmd.PersistentFlags().Lookup("version"))

	// Environment variable support
	viper.SetEnvPrefix("{{toUpper .ProjectName}}")
	viper.AutomaticEnv()

	// Add resource commands
	{{range .Resources}}rootCmd.AddCommand({{toLower .Name}}Cmd)
	{{end}}
}

func initConfig() {
	if cfgFile != "" {
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: %v\n", err)
			return
		}

		viper.AddConfigPath(home)
		viper.SetConfigType("yaml")
		viper.SetConfigName(".{{.ProjectName}}-cli")
	}

	if err := viper.ReadInConfig(); err == nil {
		fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
	}
}

func getClient() (*client.Client, error) {
	serverURL := viper.GetString("server")
	c, err := client.NewClient(serverURL, nil)
	if err != nil {
		return nil, err
	}

	// Apply version if specified
	version := viper.GetString("version")
	if version != "" {
		c = c.WithVersion(version)
	}

	return c, nil
}

func printOutput(data interface{}) error {
	switch output {
	case "json":
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)
	case "yaml":
		// TODO: Add YAML support if needed
		return fmt.Errorf("YAML output not yet implemented")
	case "table":
		// Simple table output
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)
	default:
		return fmt.Errorf("unknown output format: %s", output)
	}
}

{{range .Resources}}
// {{.Name}} commands
var {{toLower .Name}}Cmd = &cobra.Command{
	Use:   "{{toLower .Name}}",
	Short: "Manage {{.PluralName}}",
	Long:  `Create, read, update, and delete {{.PluralName}}.`,
}

var {{toLower .Name}}ListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all {{.PluralName}}",
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		items, err := c.Get{{.Name}}s(ctx)
		if err != nil {
			return fmt.Errorf("failed to list {{.PluralName}}: %w", err)
		}

		return printOutput(items)
	},
}

var {{toLower .Name}}GetCmd = &cobra.Command{
	Use:   "get [uid]",
	Short: "Get a {{.Name}} by UID",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.Get{{.Name}}(ctx, args[0])
		if err != nil {
			return fmt.Errorf("failed to get {{.Name}}: %w", err)
		}

		return printOutput(item)
	},
}

var {{toLower .Name}}CreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new {{.Name}}",
	Long: `Create a new {{.Name}}.

Examples:
  # Create from stdin
  echo '{{specToJSON .SpecFields}}' | client {{toLower .Name}} create

  # Create with --spec flag
  client {{toLower .Name}} create --spec '{{specToJSON .SpecFields}}'

Spec fields:
{{range .SpecFields}}  {{.JSONName}} ({{.Type}}){{if .Required}} [required]{{end}}
{{end}}`,
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.Create{{.Name}}Request

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.Create{{.Name}}(ctx, req)
		if err != nil {
			return fmt.Errorf("failed to create {{.Name}}: %w", err)
		}

		return printOutput(item)
	},
}

var {{toLower .Name}}UpdateCmd = &cobra.Command{
	Use:   "update [uid]",
	Short: "Update an existing {{.Name}}",
	Long: `Update an existing {{.Name}}.

Examples:
  # Update from stdin
  echo '{{specToJSON .SpecFields}}' | client {{toLower .Name}} update <uid>

  # Update with --spec flag
  client {{toLower .Name}} update <uid> --spec '{{specToJSON .SpecFields}}'

Spec fields:
{{range .SpecFields}}  {{.JSONName}} ({{.Type}}){{if .Required}} [required]{{end}}
{{end}}`,
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		// Read request from flags or stdin
		reqJSON, _ := cmd.Flags().GetString("spec")
		var req client.Update{{.Name}}Request

		if reqJSON == "" {
			// Read from stdin if no spec provided
			decoder := json.NewDecoder(os.Stdin)
			if err := decoder.Decode(&req); err != nil {
				return fmt.Errorf("failed to decode request from stdin: %w", err)
			}
		} else {
			// Parse request from JSON string
			if err := json.Unmarshal([]byte(reqJSON), &req); err != nil {
				return fmt.Errorf("failed to parse request JSON: %w", err)
			}
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		item, err := c.Update{{.Name}}(ctx, args[0], req)
		if err != nil {
			return fmt.Errorf("failed to update {{.Name}}: %w", err)
		}

		return printOutput(item)
	},
}

var {{toLower .Name}}DeleteCmd = &cobra.Command{
	Use:   "delete [uid]",
	Short: "Delete a {{.Name}}",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		c, err := getClient()
		if err != nil {
			return fmt.Errorf("failed to create client: %w", err)
		}

		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		if err := c.Delete{{.Name}}(ctx, args[0]); err != nil {
			return fmt.Errorf("failed to delete {{.Name}}: %w", err)
		}

		fmt.Printf("{{.Name}} %s deleted successfully\n", args[0])
		return nil
	},
}

func init() {
	{{toLower .Name}}Cmd.AddCommand({{toLower .Name}}ListCmd)
	{{toLower .Name}}Cmd.AddCommand({{toLower .Name}}GetCmd)
	{{toLower .Name}}Cmd.AddCommand({{toLower .Name}}CreateCmd)
	{{toLower .Name}}Cmd.AddCommand({{toLower .Name}}UpdateCmd)
	{{toLower .Name}}Cmd.AddCommand({{toLower .Name}}DeleteCmd)

	// Add spec flag for create and update commands
	{{toLower .Name}}CreateCmd.Flags().String("spec", "", "{{.Name}} specification in JSON format")
	{{toLower .Name}}UpdateCmd.Flags().String("spec", "", "{{.Name}} specification in JSON format")
}

{{end}}
