/*
 * Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
 *
 * SPDX-License-Identifier: MIT
 */

// Code generated by fabrica. DO NOT EDIT.
package server

import (
	"crypto/md5"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/alexlovelltroy/fabrica/pkg/conditional"
)

// ETagAlgorithm defines the hashing algorithm for ETags
// Configured in .fabrica.yaml: {{.ETagAlgorithm}}
const ETagAlgorithm = "{{.ETagAlgorithm}}" // sha256, md5

// ConditionalMiddleware handles ETags and conditional requests
//
// Features:
//   - Generates ETags for GET responses
//   - Validates If-Match headers for PUT/PATCH/DELETE
//   - Validates If-None-Match for conditional GET
//   - Returns 304 Not Modified when appropriate
//   - Returns 412 Precondition Failed on ETag mismatch
func ConditionalMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Set cache control headers
		w.Header().Set("Cache-Control", "private, must-revalidate")

		next.ServeHTTP(w, r)
	})
}

// GenerateETag generates an ETag for the given data
func GenerateETag(data interface{}) (string, error) {
	// Marshal to JSON for consistent hashing
	jsonData, err := json.Marshal(data)
	if err != nil {
		return "", fmt.Errorf("failed to marshal data: %w", err)
	}

	var hash string
	switch ETagAlgorithm {
	case "sha256":
		h := sha256.Sum256(jsonData)
		hash = hex.EncodeToString(h[:])
	case "md5":
		h := md5.Sum(jsonData)
		hash = hex.EncodeToString(h[:])
	default:
		return "", fmt.Errorf("unknown ETag algorithm: %s", ETagAlgorithm)
	}

	// Format as W/"<hash>" (weak ETag)
	return fmt.Sprintf(`W/"%s"`, hash[:16]), nil
}

// CheckIfMatch validates If-Match header for conditional updates
//
// Returns:
//   - true if the condition passes (update should proceed)
//   - false if the condition fails (returns 412 Precondition Failed)
func CheckIfMatch(w http.ResponseWriter, r *http.Request, currentETag string) bool {
	ifMatch := r.Header.Get("If-Match")
	if ifMatch == "" {
		// No If-Match header, allow update
		return true
	}

	// Parse If-Match (can be comma-separated list)
	tags := strings.Split(ifMatch, ",")
	for _, tag := range tags {
		tag = strings.TrimSpace(tag)
		if tag == "*" || tag == currentETag {
			return true
		}
	}

	// ETag mismatch - return 412 Precondition Failed
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusPreconditionFailed)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error": "Precondition failed",
		"message": "Resource has been modified. Please fetch the latest version and retry.",
		"current_etag": currentETag,
		"provided_etag": ifMatch,
	})
	return false
}

// CheckIfNoneMatch validates If-None-Match header for conditional GET
//
// Returns:
//   - true if the resource should be returned (modified)
//   - false if 304 Not Modified should be returned
func CheckIfNoneMatch(w http.ResponseWriter, r *http.Request, currentETag string) bool {
	ifNoneMatch := r.Header.Get("If-None-Match")
	if ifNoneMatch == "" {
		// No If-None-Match header, return resource
		return true
	}

	// Parse If-None-Match (can be comma-separated list)
	tags := strings.Split(ifNoneMatch, ",")
	for _, tag := range tags {
		tag = strings.TrimSpace(tag)
		if tag == "*" || tag == currentETag {
			// ETag matches - return 304 Not Modified
			w.WriteHeader(http.StatusNotModified)
			return false
		}
	}

	// ETag doesn't match - return resource
	return true
}

// SetETag sets the ETag header on the response
func SetETag(w http.ResponseWriter, etag string) {
	w.Header().Set("ETag", etag)
}

// SetCacheControl sets cache control headers
func SetCacheControl(w http.ResponseWriter, directive string) {
	w.Header().Set("Cache-Control", directive)
}
