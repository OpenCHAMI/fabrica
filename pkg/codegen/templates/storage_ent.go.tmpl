// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides storage functions using Ent as the backend.
// The functions maintain the same interface as file storage for compatibility.

package storage

import (
	"context"
	"fmt"

	"{{.ModulePath}}/internal/storage/ent"
	"{{.ModulePath}}/internal/storage/ent/resource"
	{{range .Resources}}
	{{.PackageAlias}} "{{.Package}}"
	{{end}}
)

// Ent client (initialized in main.go)
var entClient *ent.Client

// SetEntClient sets the Ent client for storage operations
func SetEntClient(client *ent.Client) {
	entClient = client
}

{{range .Resources}}
// LoadAll{{.StorageName}}s loads all {{.Name}} resources from Ent storage
func LoadAll{{.StorageName}}s(ctx context.Context) ([]*{{.PackageAlias}}.{{.Name}}, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(resource.KindEQ("{{.Name}}")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load {{.Name}} resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*{{.PackageAlias}}.{{.Name}}
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*{{.PackageAlias}}.{{.Name}}))
	}

	return resources, nil
}

// Load{{.StorageName}} loads a single {{.Name}} resource by UID from Ent storage
func Load{{.StorageName}}(ctx context.Context, uid string) (*{{.PackageAlias}}.{{.Name}}, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			resource.UIDEQ(uid),
			resource.KindEQ("{{.Name}}"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load {{.Name}} %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*{{.PackageAlias}}.{{.Name}}), nil
}

// Save{{.StorageName}} saves a {{.Name}} resource to Ent storage
func Save{{.StorageName}}(ctx context.Context, resource *{{.PackageAlias}}.{{.Name}}) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert {{.Name}} to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(resource.UIDEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check {{.Name}} existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create {{.Name}}: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update {{.Name}}: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// Delete{{.StorageName}} deletes a {{.Name}} resource from Ent storage
func Delete{{.StorageName}}(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			resource.UIDEQ(uid),
			resource.KindEQ("{{.Name}}"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete {{.Name}} %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}

{{end}}
