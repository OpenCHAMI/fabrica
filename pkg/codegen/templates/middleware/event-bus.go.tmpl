/*
 * Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
 *
 * SPDX-License-Identifier: MIT
 */

// Code generated by fabrica. DO NOT EDIT.
package server

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/alexlovelltroy/fabrica/pkg/events"
)

// EventBusType defines the event bus implementation
// Configured in .fabrica.yaml: {{.EventBusType}}
const EventBusType = "{{.EventBusType}}" // memory, nats, kafka

// EventsEnabled indicates if event publishing is enabled
// Configured in .fabrica.yaml: {{.EventsEnabled}}
const EventsEnabled = {{.EventsEnabled}}

var (
	// GlobalEventBus is the singleton event bus instance
	GlobalEventBus events.EventBus
)

// InitializeEventBus sets up the event bus based on configuration
func InitializeEventBus() error {
	if !EventsEnabled {
		log.Println("Events are disabled in configuration")
		return nil
	}

	var err error

	switch EventBusType {
	case "memory":
		GlobalEventBus, err = initMemoryBus()
	case "nats":
		GlobalEventBus, err = initNATSBus()
	case "kafka":
		GlobalEventBus, err = initKafkaBus()
	default:
		return fmt.Errorf("unsupported event bus type: %s", EventBusType)
	}

	if err != nil {
		return fmt.Errorf("failed to initialize %s event bus: %w", EventBusType, err)
	}

	log.Printf("Successfully initialized %s event bus", EventBusType)
	return nil
}

// initMemoryBus creates an in-memory event bus
func initMemoryBus() (events.EventBus, error) {
	bus := events.NewInMemoryEventBus(100, 5)
	events.SetGlobalEventBus(bus)
	return bus, nil
}

// initNATSBus creates a NATS-based event bus
func initNATSBus() (events.EventBus, error) {
	// TODO: Implement NATS connection from config
	// natsURL := os.Getenv("NATS_URL")
	// if natsURL == "" {
	//     natsURL = "nats://localhost:4222"
	// }

	return nil, fmt.Errorf("NATS event bus not yet implemented")
}

// initKafkaBus creates a Kafka-based event bus
func initKafkaBus() (events.EventBus, error) {
	// TODO: Implement Kafka connection from config
	// brokers := os.Getenv("KAFKA_BROKERS")
	// if brokers == "" {
	//     brokers = "localhost:9092"
	// }

	return nil, fmt.Errorf("Kafka event bus not yet implemented")
}

// PublishEvent publishes a generic event to the event bus
func PublishEvent(ctx context.Context, eventType string, source string, data interface{}) error {
	if !EventsEnabled || GlobalEventBus == nil {
		return fmt.Errorf("events are not enabled")
	}

	// Create events.Event using the events package
	evt, err := events.NewEvent(eventType, source, data)
	if err != nil {
		return fmt.Errorf("failed to create event: %w", err)
	}

	return GlobalEventBus.Publish(ctx, *evt)
}

// PublishResourceEvent publishes a resource lifecycle event
func PublishResourceEvent(ctx context.Context, action, resourceType, resourceID string, resource interface{}) error {
	eventType := fmt.Sprintf("com.fabrica.%s.%s", resourceType, action)
	source := fmt.Sprintf("/api/%s/%s", resourceType, resourceID)

	eventData := map[string]interface{}{
		"action":   action,
		"type":     resourceType,
		"id":       resourceID,
		"resource": resource,
		"timestamp": time.Now().UTC(),
	}

	return PublishEvent(ctx, eventType, source, eventData)
}

// SubscribeToEvents subscribes to events matching the given type pattern
func SubscribeToEvents(ctx context.Context, eventTypePattern string, handler func(ctx context.Context, event events.Event) error) error {
	if !EventsEnabled || GlobalEventBus == nil {
		return fmt.Errorf("events are not enabled")
	}

	_, err := GlobalEventBus.Subscribe(eventTypePattern, handler)
	return err
}

// CloseEventBus gracefully shuts down the event bus
func CloseEventBus() error {
	if !EventsEnabled || GlobalEventBus == nil {
		return nil
	}

	log.Println("Closing event bus...")
	return GlobalEventBus.Close()
}

// EventMiddleware adds event publishing to HTTP handlers
func EventMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// TODO: Capture response for event publishing
		// This would require a response recorder to capture status and body

		next.ServeHTTP(w, r)

		// Publish event based on request (optional)
		// Can be done in individual handlers instead
	})
}
