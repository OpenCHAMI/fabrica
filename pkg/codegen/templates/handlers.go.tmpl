// Code generated by codegen. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file contains REST API handlers for {{.Name}} resources.
// Generated from: pkg/codegen/templates/handlers.go.tmpl
//
// To modify this code:
//   1. Edit the template file: pkg/codegen/templates/handlers.go.tmpl
//   2. Run 'make dev' to regenerate
//   3. Do NOT edit this file directly - changes will be lost
//
// Generated handlers provide:
//   - GET {{.URLPath}} (list all {{.PluralName}})
//   - GET {{.URLPath}}/{uid} (get specific {{.Name}})
//   - POST {{.URLPath}} (create new {{.Name}})
//   - PUT {{.URLPath}}/{uid} (update {{.Name}})
//   - PATCH {{.URLPath}}/{uid} (patch {{.Name}})
//   - DELETE {{.URLPath}}/{uid} (delete {{.Name}})
//
// Authentication: {{if .RequiresAuth}}ENABLED{{else}}DISABLED{{end}}
// Storage: Uses storage.Load{{.StorageName}}*/Save{{.StorageName}}*/Delete{{.StorageName}}*
// Version Support: Available (see version context in handlers)
//
// To enable full version conversion for this resource:
//   1. Create v2beta1 package: pkg/resources/{{toLower .Name}}/v2beta1/
//   2. Implement converter: v2beta1/converter.go
//   3. Add version-aware storage: storage.Load{{.StorageName}}WithVersion()
//   4. Register versions in cmd/server/main.go
//
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/alexlovelltroy/fabrica/pkg/events"
	"github.com/alexlovelltroy/fabrica/pkg/patch"
	"github.com/alexlovelltroy/fabrica/pkg/resource"
	"github.com/alexlovelltroy/fabrica/pkg/validation"
	"github.com/alexlovelltroy/fabrica/pkg/versioning"
	"{{.Package}}"
	"{{.ModulePath}}/internal/storage"
)

// Get{{.Name}}s returns all {{.Name}} resources
func Get{{.Name}}s(w http.ResponseWriter, r *http.Request) {
{{if .RequiresAuth}}
	// Check authorization - extract auth context (may be nil for permissive policies)
	auth, _ := GetAuthFromContext(r.Context())

	if policy, exists := policyRegistry.GetPolicy("{{.Name}}"); exists {
		if decision := policy.CanList(r.Context(), auth, r); !decision.Allowed {
			status := http.StatusForbidden
			if auth == nil {
				status = http.StatusUnauthorized
			}
			respondError(w, status, fmt.Errorf("access denied: %s", decision.Reason))
			return
		}
	} else {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("no policy configured for {{.Name}}"))
		return
	}
{{end}}
	{{camelCase .PluralName}}, err := storage.LoadAll{{.StorageName}}s(r.Context())
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to load {{.PluralName}}: %w", err))
		return
	}
	respondJSON(w, http.StatusOK, {{camelCase .PluralName}})
}

// Get{{.Name}} returns a specific {{.Name}} resource by UID
func Get{{.Name}}(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("{{.Name}} UID is required"))
		return
	}

	// Version context available here for version-aware operations
	// versionCtx := versioning.GetVersionContext(r.Context())
	// Requested version: versionCtx.ServeVersion
	// To enable: replace storage.Load{{.StorageName}}() with version-aware function

{{if .RequiresAuth}}
	// Check authorization - extract auth context (may be nil for permissive policies)
	auth, _ := GetAuthFromContext(r.Context())

	if policy, exists := policyRegistry.GetPolicy("{{.Name}}"); exists {
		if decision := policy.CanGet(r.Context(), auth, r, uid); !decision.Allowed {
			status := http.StatusForbidden
			if auth == nil {
				status = http.StatusUnauthorized
			}
			respondError(w, status, fmt.Errorf("access denied: %s", decision.Reason))
			return
		}
	} else {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("no policy configured for {{.Name}}"))
		return
	}
{{end}}

	{{camelCase .Name}}, err := storage.Load{{.StorageName}}(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("{{.Name}} not found: %w", err))
		return
	}
	respondJSON(w, http.StatusOK, {{camelCase .Name}})
}

// Create{{.Name}} creates a new {{.Name}} resource
func Create{{.Name}}(w http.ResponseWriter, r *http.Request) {
	var req Create{{.Name}}Request
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// Get version context from request
	versionCtx := versioning.GetVersionContext(r.Context())

	uid, err := resource.GenerateUIDForResource("{{.Name}}")
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to generate UID: %w", err))
		return
	}

	{{camelCase .Name}} := &{{.PackageAlias}}.{{.Name}}{
		Resource: resource.Resource{
			APIVersion:    versionCtx.GroupVersion,
			Kind:          "{{.Name}}",
			SchemaVersion: versionCtx.ServeVersion,
		},
		Spec: req.{{.Name}}Spec,
	}

	{{camelCase .Name}}.Metadata.Initialize(req.Name, uid)

	// Set labels and annotations
	for k, v := range req.Labels {
		{{camelCase .Name}}.SetLabel(k, v)
	}
	for k, v := range req.Annotations {
		{{camelCase .Name}}.SetAnnotation(k, v)
	}

	// Layer 2: Fabrica struct tag validation
	if err := validation.ValidateResource({{camelCase .Name}}); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	// Layer 3: Custom business logic validation
	if err := validation.ValidateWithContext(r.Context(), {{camelCase .Name}}); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	// Set initial status

	// Save (Layer 1: Ent validation happens automatically if using Ent storage)
	if err := storage.Save{{.StorageName}}(r.Context(), {{camelCase .Name}}); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save {{.Name}}: %w", err))
		return
	}

	// Publish resource created event
	if err := events.PublishResourceCreated(r.Context(), "{{.Name}}", {{camelCase .Name}}.GetUID(), {{camelCase .Name}}.GetName(), {{camelCase .Name}}); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource created event for {{.Name}} %s: %v\n", {{camelCase .Name}}.GetUID(), err)
	}

	respondJSON(w, http.StatusCreated, {{camelCase .Name}})
}

// Update{{.Name}} updates an existing {{.Name}} resource
func Update{{.Name}}(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("{{.Name}} UID is required"))
		return
	}

	{{camelCase .Name}}, err := storage.Load{{.StorageName}}(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("{{.Name}} not found: %w", err))
		return
	}

	var req Update{{.Name}}Request
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// Apply updates
	if req.Name != "" {
		{{camelCase .Name}}.SetName(req.Name)
	}

	// Update spec fields - merge non-zero values from request
	{{camelCase .Name}}.Spec = req.{{.Name}}Spec

	// Update labels and annotations
	for k, v := range req.Labels {
		{{camelCase .Name}}.SetLabel(k, v)
	}
	for k, v := range req.Annotations {
		{{camelCase .Name}}.SetAnnotation(k, v)
	}

	{{camelCase .Name}}.Touch()

	if err := storage.Save{{.StorageName}}(r.Context(), {{camelCase .Name}}); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save {{.Name}}: %w", err))
		return
	}

	// Publish resource updated event
	updateMetadata := map[string]interface{}{
		"updatedAt": {{camelCase .Name}}.Metadata.UpdatedAt,
	}
	if err := events.PublishResourceUpdated(r.Context(), "{{.Name}}", {{camelCase .Name}}.GetUID(), {{camelCase .Name}}.GetName(), {{camelCase .Name}}, updateMetadata); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource updated event for {{.Name}} %s: %v\n", {{camelCase .Name}}.GetUID(), err)
	}

	respondJSON(w, http.StatusOK, {{camelCase .Name}})
}

// Patch{{.Name}} patches an existing {{.Name}} resource spec using JSON Merge Patch, JSON Patch, or Shorthand Patch
// Only the spec portion of the resource can be patched - metadata and status are API-managed
func Patch{{.Name}}(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("{{.Name}} UID is required"))
		return
	}

	{{camelCase .Name}}, err := storage.Load{{.StorageName}}(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("{{.Name}} not found: %w", err))
		return
	}

	// Read patch document
	patchData, err := io.ReadAll(r.Body)
	if err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("failed to read patch data: %w", err))
		return
	}

	// Marshal current spec to JSON for patching (only allow spec modifications)
	currentSpecJSON, err := json.Marshal({{camelCase .Name}}.Spec)
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to marshal current spec: %w", err))
		return
	}

	// Detect patch type from Content-Type header
	contentType := r.Header.Get("Content-Type")
	patchType := patch.DetectPatchType(contentType)

	// Apply patch to spec only
	patchResult, err := patch.ApplyPatchWithOptions(currentSpecJSON, patchData, patchType, patch.PatchOptions{
		AllowAddFields:    true,
		AllowRemoveFields: true,
	})
	if err != nil {
		respondError(w, http.StatusUnprocessableEntity, fmt.Errorf("failed to apply patch to spec: %w", err))
		return
	}

	// Unmarshal the patched result back to the spec
	if err := json.Unmarshal(patchResult.Updated, &{{camelCase .Name}}.Spec); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to unmarshal patched spec: %w", err))
		return
	}

	// Touch to update metadata
	{{camelCase .Name}}.Touch()

	// Save the patched resource
	if err := storage.Save{{.StorageName}}(r.Context(), {{camelCase .Name}}); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save patched {{.Name}}: %w", err))
		return
	}

	// Publish resource patched event
	patchMetadata := map[string]interface{}{
		"patchType": patchType,
		"updatedAt": {{camelCase .Name}}.Metadata.UpdatedAt,
	}
	if err := events.PublishResourcePatched(r.Context(), "{{.Name}}", {{camelCase .Name}}.GetUID(), {{camelCase .Name}}.GetName(), {{camelCase .Name}}, patchMetadata); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource patched event for {{.Name}} %s: %v\n", {{camelCase .Name}}.GetUID(), err)
	}

	respondJSON(w, http.StatusOK, {{camelCase .Name}})
}

// Delete{{.Name}} deletes a {{.Name}} resource
func Delete{{.Name}}(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("{{.Name}} UID is required"))
		return
	}

	// Load resource before deletion for event publishing
	{{camelCase .Name}}, err := storage.Load{{.StorageName}}(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("{{.Name}} not found: %w", err))
		return
	}

	if err := storage.Delete{{.StorageName}}(r.Context(), uid); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to delete {{.Name}}: %w", err))
		return
	}

	// Publish resource deleted event
	deleteMetadata := map[string]interface{}{
		"deletedAt": time.Now(),
	}
	if err := events.PublishResourceDeleted(r.Context(), "{{.Name}}", {{camelCase .Name}}.GetUID(), {{camelCase .Name}}.GetName(), deleteMetadata); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource deleted event for {{.Name}} %s: %v\n", {{camelCase .Name}}.GetUID(), err)
	}

	respondJSON(w, http.StatusOK, &DeleteResponse{
		Message: "{{.Name}} deleted successfully",
		UID:     uid,
	})
}
