/*
 * Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
 *
 * SPDX-License-Identifier: MIT
 */

// Code generated by fabrica. DO NOT EDIT.
package server

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"

	cloudevents "github.com/cloudevents/sdk-go/v2"
	"github.com/alexlovelltroy/fabrica/pkg/events"
)

// EventBusType defines the event bus implementation
// Configured in .fabrica.yaml: {{.EventBusType}}
const EventBusType = "{{.EventBusType}}" // memory, nats, kafka

// EventsEnabled indicates if event publishing is enabled
// Configured in .fabrica.yaml: {{.EventsEnabled}}
const EventsEnabled = {{.EventsEnabled}}

var (
	// GlobalEventBus is the singleton event bus instance
	GlobalEventBus events.EventBus

	// EventClient is the CloudEvents client for publishing
	EventClient cloudevents.Client
)

// InitializeEventBus sets up the event bus based on configuration
func InitializeEventBus() error {
	if !EventsEnabled {
		log.Println("Events are disabled in configuration")
		return nil
	}

	var err error

	switch EventBusType {
	case "memory":
		GlobalEventBus, err = initMemoryBus()
	case "nats":
		GlobalEventBus, err = initNATSBus()
	case "kafka":
		GlobalEventBus, err = initKafkaBus()
	default:
		return fmt.Errorf("unsupported event bus type: %s", EventBusType)
	}

	if err != nil {
		return fmt.Errorf("failed to initialize %s event bus: %w", EventBusType, err)
	}

	log.Printf("Successfully initialized %s event bus", EventBusType)
	return nil
}

// initMemoryBus creates an in-memory event bus
func initMemoryBus() (events.EventBus, error) {
	bus := events.NewMemoryBus()

	// Create CloudEvents client with memory transport
	client, err := cloudevents.NewClientHTTP()
	if err != nil {
		return nil, fmt.Errorf("failed to create CloudEvents client: %w", err)
	}
	EventClient = client

	return bus, nil
}

// initNATSBus creates a NATS-based event bus
func initNATSBus() (events.EventBus, error) {
	// TODO: Implement NATS connection from config
	// natsURL := os.Getenv("NATS_URL")
	// if natsURL == "" {
	//     natsURL = "nats://localhost:4222"
	// }

	return nil, fmt.Errorf("NATS event bus not yet implemented")
}

// initKafkaBus creates a Kafka-based event bus
func initKafkaBus() (events.EventBus, error) {
	// TODO: Implement Kafka connection from config
	// brokers := os.Getenv("KAFKA_BROKERS")
	// if brokers == "" {
	//     brokers = "localhost:9092"
	// }

	return nil, fmt.Errorf("Kafka event bus not yet implemented")
}

// PublishEvent publishes a CloudEvent to the event bus
func PublishEvent(ctx context.Context, eventType, source string, data interface{}) error {
	if !EventsEnabled || GlobalEventBus == nil {
		return nil // Events disabled, skip silently
	}

	event := cloudevents.NewEvent()
	event.SetID(fmt.Sprintf("%d", time.Now().UnixNano()))
	event.SetType(eventType)
	event.SetSource(source)
	event.SetTime(time.Now())

	if err := event.SetData(cloudevents.ApplicationJSON, data); err != nil {
		return fmt.Errorf("failed to set event data: %w", err)
	}

	return GlobalEventBus.Publish(ctx, event)
}

// PublishResourceEvent publishes a resource lifecycle event
func PublishResourceEvent(ctx context.Context, action, resourceType, resourceID string, resource interface{}) error {
	eventType := fmt.Sprintf("com.fabrica.%s.%s", resourceType, action)
	source := fmt.Sprintf("/api/%s/%s", resourceType, resourceID)

	eventData := map[string]interface{}{
		"action":   action,
		"type":     resourceType,
		"id":       resourceID,
		"resource": resource,
		"timestamp": time.Now().UTC(),
	}

	return PublishEvent(ctx, eventType, source, eventData)
}

// SubscribeToEvents subscribes to events matching the given type pattern
func SubscribeToEvents(ctx context.Context, eventTypePattern string, handler events.EventHandler) error {
	if !EventsEnabled || GlobalEventBus == nil {
		return fmt.Errorf("events are not enabled")
	}

	return GlobalEventBus.Subscribe(ctx, eventTypePattern, handler)
}

// CloseEventBus gracefully shuts down the event bus
func CloseEventBus(ctx context.Context) error {
	if !EventsEnabled || GlobalEventBus == nil {
		return nil
	}

	log.Println("Closing event bus...")
	return GlobalEventBus.Close(ctx)
}

// EventMiddleware adds event publishing to HTTP handlers
func EventMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Add event publishing context
		ctx := r.Context()

		// TODO: Capture response for event publishing
		// This would require a response recorder to capture status and body

		next.ServeHTTP(w, r)

		// Publish event based on request (optional)
		// Can be done in individual handlers instead
	})
}
